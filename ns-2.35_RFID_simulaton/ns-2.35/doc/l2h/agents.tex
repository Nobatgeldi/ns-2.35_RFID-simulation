\%
\chapter{Agents}
\label{sec:agents}

Agents represent endpoints where network-layer
packets are constructed or consumed, and are used in the implementation
of protocols at various layers.
The \clsref{Agent}{../ns-2/agent.h} has an implementation partly in
OTcl and partly in C++.
The C++ implementation is contained in \textasciitilde\emph{ns}/{agent.cc} and
\textasciitilde\emph{ns}/{agent.h}, and the OTcl support is in
\textasciitilde\emph{ns}/{tcl/lib/ns-agent.tcl}.

\section{Agent state}
\label{sec:agentstate}

The C++ \clsref{Agent}{../ns-2/agent.h} includes enough internal state
to assign various fields to a simulated packet before
it is sent.
This state includes the following:

\begin{tabularx}{\linewidth}{rX}
{\tt addr\\_} & node address of myself (source address in packets) \\
{\tt dst\\_} & where I am sending packets to \\
{\tt size\\_} & packet size in bytes (placed into the common packet header) \\
{\tt type\\_} & type of packet (in the common header, see packet.h) \\
{\tt fid\\_} & the IP flow identifier (formerly {\em class} in ns-1) \\
{\tt prio\\_} & the IP priority field \\
{\tt flags\\_} & packet flags (similar to ns-1) \\
{\tt defttl\\_} & default IP ttl value \\
\end{tabularx}

These variables may be modified by any class derived from {\tt Agent},
although not all of them may be needed by any particular agent.

\section{Agent methods}
\label{sec:agentmethods}

The \clsref{Agent}{../ns-2/agent.h} supports packet generation and reception.
The following member functions are implemented by the C++ Agent class, and are
generally {\em not} over-ridden by derived classes:

\begin{tabularx}{\linewidth}{rX}
\fcn[]{Packet* allocpkt} & allocate new packet and assign its fields \\
\fcn[int]{Packet* allocpkt} & allocate new packet with a data payload of n bytes and assign its fields \\
\end{tabularx}

The following member functions are also defined by the class Agent,
but {\em are} intended to be over-ridden by classes deriving from Agent:

\begin{tabularx}{\linewidth}{rX}
  \fcn[timeout number]{void timeout} & subclass-specific time out method \\
  \fcn[Packet*, Handler*]{void recv} & receiving agent main receive path \\
\end{tabularx}

The \fcn[]{allocpkt} method is used by derived classes
to create packets to send.
The function fills in the following fields
\href{in the common packet header}{Section}{chap:pformat}:
{\tt uid, ptype, size}, and the following fields in the IP header:
{\tt src, dst, flowid, prio, ttl}.
It also zero-fills in the following fields of the Flags header:
{\tt ecn, pri, usr1, usr2}.
Any packet header information not included in these lists must
be must be handled in the classes derived from {\tt Agent}.

The \fcn[]{recv} method is the main entry point for an
Agent which receives packets, and
is invoked by upstream nodes when sending a packet.
In most cases, Agents make no use of the second argument (the handler
defined by upstream nodes).

\section{Protocol Agents}
\label{sec:protoagents}

There are several agents supported in the simulator.
These are their names in OTcl:

\begin{longtable}{rl}
  TCP & a ``Tahoe'' TCP sender (cwnd = 1 on any loss)   \\
  TCP/Reno & a ``Reno'' TCP sender  (with fast recovery)        \\
  TCP/Newreno & a modified Reno TCP sender (changes fast recovery)      \\
  TCP/Sack1 & a SACK TCP sender \\
  TCP/Fack & a ``forward'' SACK sender TCP      \\
  TCP/FullTcp & a more full-functioned TCP with 2-way traffic   \\
  TCP/Vegas & a ``Vegas'' TCP sender    \\
  TCP/Vegas/RBP & a Vegas TCP with ``rate based pacing''        \\
  TCP/Vegas/RBP & a Reno TCP with ``rate based pacing'' \\
  TCP/Asym & an experimental Tahoe TCP for asymmetric links     \\
  TCP/Reno/Asym & an experimental Reno TCP for asymmetric links \\
  TCP/Newreno/Asym & an experimental Newreno TCP for asymmetric links   \\
  TCPSink & a Reno or Tahoe TCP receiver (not used for FullTcp) \\
  TCPSink/DelAck & a TCP delayed-ACK receiver   \\
  TCPSink/Asym & an experimental  TCP sink for asymmetric links \\
  TCPSink/Sack1 & a SACK TCP receiver   \\
  TCPSink/Sack1/DelAck & a delayed-ACK SACK TCP receiver        \\
        \\
  UDP & a basic UDP agent\\
	\\
  RTP & an RTP sender and receiver  \\
  RTCP & an RTCP sender and receiver    \\
        \\
  LossMonitor & a packet sink which checks for losses   \\
        \\
  IVS/Source & an IVS source    \\
  IVS/Receiver & an IVS receiver        \\
        \\
  CtrMcast/Encap & a ``centralised multicast'' encapsulator     \\
  CtrMcast/Decap & a ``centralised multicast'' de-encapsulator  \\
  Message & a protocol to carry textual messages        \\
  Message/Prune & processes multicast routing prune messages    \\
        \\
  SRM & an SRM agent with non-adaptive timers   \\
  SRM/Adaptive & an SRM agent with adaptive timers      \\
        \\
  Tap & interfaces the simulator to a live network      \\
        \\
  Null & a degenerate agent which discards packets      \\
        \\
  rtProto/DV & distance-vector routing protocol agent   \\
\end{longtable}

Agents are used in the implementation of protocols at various layers.
Thus, for some transport protocols (e.g.~UDP) the distribution
of packet sizes and/or inter-departure times
may be dictated by some separate
object representing the demands of an application.  To this end, agents
expose an application programming interface (API) to the application.
For agents used in the implementation of lower-layer protocols
(e.g. routing agents), size and departure timing is generally dictated
by the agent's own processing of protocol messages.

\section{OTcl Linkage}
\label{sec:agentotcl}

Agents may be created within OTcl and an agent's internal
state can be modified by use of Tcl's {\tt set} function and
any Tcl functions an Agent (or its base classes) implements.
Note that some of an Agent's internal state may exist
only within OTcl, and is thus is not directly accessible from C++.

\subsection{Creating and Manipulating Agents}
\label{sec:agentcreateotcl}

The following example illustrates the creation and modification
of an Agent in OTcl:
\begin{verbatim}
        set newtcp [new Agent/TCP] # create new object (and C++ shadow object);
        \$newtcp set window\_ 20 # sets the tcp agent's window to 20;
        \$newtcp target \$dest # target is implemented in Connector class;
        \$newtcp set portID\_ 1 # exists only in OTcl, not in C++;
\end{verbatim}

\subsection{Default Values}
\label{sec:agentdefaults}

Default values for member variables, those visible in OTcl only and those
linked between OTcl and C++ with {\tt bind} are initialized
in the \textasciitilde\emph{ns}/{tcl/lib/ns-default.tcl} file.  For example,
{\tt Agent} is initialized as follows:
\begin{verbatim}
        Agent set fid\_ 0
        Agent set prio\_ 0
        Agent set addr\_ 0
        Agent set dst\_ 0
        Agent set flags\_ 0
\end{verbatim}

Generally these initializations are placed in the OTcl namespace
before any objects of these types are created.
Thus, when an {\tt Agent} object
is created, the calls to {\tt bind}
in the objects' constructors will causes the corresponding member variables
to be set to these specified defaults.

\subsection{OTcl Methods}
\label{sec:agentmethodsotcl}

The instance procedures defined for the OTcl {\tt Agent} class are
currently found in \textasciitilde\emph{ns}/{tcl/lib/ns-agent.tcl}.
They are as follows:
\begin{tabularx}{\linewidth}{rX}
{\tt port} & the agent's port identifier \\
{\tt dst-port} & the destination's port identifier \\
{\tt attach-source \tup{stype}} & create and attach a Source object to an agent \\
\end{tabularx}

\section{Examples: Tcp, TCP Sink Agents}
\label{sec:agentexample}

The \clsref{TCP}{../ns-2/tcp.h} represents a simplified TCP sender.
It sends data to a {\tt TCPSink} agent and processes its acknowledgments.
It has a separate object associated with it which represents
an application's demand.
By looking at the \clsref{TCPAgent}{../ns-2/tcp.h} and
 \clsref{TCPSinkAgent}{../ns-2/tcp-sink.h},
we may see how relatively complex agents are constructed.
An example from the Tahoe TCP agent {\tt TCPAgent} is also given
to illustrate the use of timers.

\subsection{Creating the Agent}
\label{sec:createtcpsimple}

The following OTcl code fragment creates a {\tt TCP} agent
and sets it up:
\begin{verbatim}
        set tcp [new Agent/TCP]         # create sender agent;
        \$tcp set fid\_ 2                 # set IP-layer flow ID;
        set sink [new Agent/TCPSink]    # create receiver agent;
        \$ns attach-agent \$n0 \$tcp       # put sender on node \$n0;
        \$ns attach-agent \$n3 \$sink      # put receiver on node \$n3;
        \$ns connect \$tcp \$sink          # establish TCP connection;
        set ftp [new Application/FTP]        # create an FTP source "application";
        \$ftp attach-agent \$tcp            # associate FTP with the TCP sender;
        \$ns at 1.2 "\$ftp start"  #arrange for FTP to start at time 1.2 sec;
\end{verbatim}
The OTcl instruction {\tt new Agent/TCP} results in the
creation of a C++ {\tt TcpAgent} class object.
Its constructor first invokes the constructor of the
{\tt Agent} base class and then performs its own bindings.
These two constructors appear as follows:
\begin{verbatim}
{\rm The TcpSimpleAgent constructor (\textasciitilde\emph{ns}/{tcp.cc}):}

        TcpAgent::TcpAgent() : Agent(PT\_TCP), rtt\_active\_(0), rtt\_seq\_(-1),
                        rtx\_timer\_(this), delsnd\_timer\_(this)
        {
                bind("window\_", &wnd\_);
                bind("windowInit\_", &wnd\_init\_);
                bind("windowOption\_", &wnd\_option\_);
                bind("windowConstant\_", &wnd\_const\_);
                \ldots
                bind("off\_ip\_", &off\_ip\_);
                bind("off\_tcp\_", &off\_tcp\_);
                \ldots
        }

{\rm The Agent constructor (\textasciitilde\emph{ns}/{agent.cc}):}

        Agent::Agent(int pkttype) : 
                addr\_(-1), dst\_(-1), size\_(0), type\_(pkttype), fid\_(-1),
                prio\_(-1), flags\_(0)
        {
                memset(pending\_, 0, sizeof(pending\_)); /* timers /
                // this is really an IP agent, so set up
                // for generating the appropriate IP fields\ldots
                bind("addr\_", (int*)&addr\_);
                bind("dst\_", (int*)&dst\_);
                bind("fid\_", (int*)&fid\_);
                bind("prio\_", (int*)&prio\_);
                bind("flags\_", (int*)&flags\_);
                \ldots
        }
\end{verbatim}
These code fragments illustrate the common case where an agent's
constructor passes a packet type identifier to the {\tt Agent}
constructor.
The values for the various packet types are
\href{used by the packet tracing facility}{Section}{sec:traceptype}
and are defined in \textasciitilde\emph{ns}/{trace.h}.
The variables which are bound in the {\tt TcpAgent} constructor
are ordinary instance/member variables for the class
with the exception of the special integer values {\tt off\_tcp\_}
and {\tt off\_ip\_}.
These are needed in order to access a TCP header and IP header, respectively.
\href{Additional details are in the section on packet headers}{Section}{sec:ppackethdr}.

Note that the {\tt TcpAgent} constructor contains initializations for
two timers, {\tt rtx\_timer\_} and {\tt delsnd\_timer\_}.

{\tt TimerHandler} 
objects are initialized by providing a pointer (the {\tt this} pointer) to
the relevant agent.

\subsection{Starting the Agent}
\label{sec:starttcp}

The {\tt TcpAgent} agent is started in the example when its
FTP source receives the {\tt start} directive at time 1.2.
The {\tt start} operation is an instance procedure defined on the
\href{class Application/FTP}{Section}{sec:simapps}.
It is defined in \textasciitilde\emph{ns}/{tcl/lib/ns-source.tcl} as follows:
\begin{verbatim}
        Application/FTP instproc start {} {
                [\$self agent] send -1
        }
\end{verbatim}
In this case, {\tt agent} refers to our simple TCP agent and
{\tt send -1} is analogous to sending an arbitrarily large file.

The call to {\tt send} eventually results in the simple TCP sender
generating packets.
The following function {\tt output} performs this:
\begin{verbatim}
        void TcpAgent::output(int seqno, int reason)
        {
                Packet* p = allocpkt();
                hdr\_tcp *tcph = (hdr\_tcp*)p-\>access(off\_tcp\_);
                double now = Scheduler::instance().clock();
                tcph-\>seqno() = seqno;
                tcph-\>ts() = now;
                tcph-\>reason() = reason;
                Connector::send(p, 0);
                \ldots
                if (!(rtx\_timer\_.status() == TIMER\_PENDING))
                        /* No timer pending.  Schedule one. */
                        set\_rtx\_timer();
        }
\end{verbatim}
Here we see an illustration of the use of the \fcn[]{Agent::allocpkt} method.
This output routine first allocates a new packet
(with its common and IP headers already filled in), but then must fill
in the appropriate TCP-layer header fields.
To find the TCP header in a packet 
(\href{assuming it has been enabled}{Section}{sec:packethdrmgr})
the {\tt off\_tcp\_} must be properly initialized,
as illustrated in the constructor.
The packet \fcn[]{access} method returns a pointer to the TCP header,
its sequence number and time stamp fields are filled in,
and the \fcn[]{send} method of the class Connector is called
to send the packet downstream one hop.
Note that the C++ {\tt ::} scoping operator is used here to avoid
calling \fcn[]{TcpSimpleAgent::send} (which is also defined).
The check for a pending timer uses the timer method \fcn[]{status} which
is defined in the base class TimerHandler.
It is used here to set a retransmission timer if one is not already set
(a TCP sender only sets one timer per window of packets on each connection).

\subsection{Processing Input at Receiver}
\label{sec:tcpsink}

Many of the TCP agents can be used with the
\clsref{TCPSink}{../ns-2/tcp-sink.h} as the peer.
This class defines the \fcn[]{recv} and \fcn[]{ack} methods as follows:
\begin{verbatim}
        void TcpSink::recv(Packet* pkt, Handler*)
        {
                hdr\_tcp *th = (hdr\_tcp*)pkt-\>access(off\_tcp\_);
                acker\_-\>update(th-\>seqno());
                ack(pkt);
                Packet::free(pkt);
        }

        void TcpSink::ack(Packet* opkt)
        {
                Packet* npkt = allocpkt();
        
                hdr\_tcp *otcp = (hdr\_tcp*)opkt-\>access(off\_tcp\_);
                hdr\_tcp *ntcp = (hdr\_tcp*)npkt-\>access(off\_tcp\_);
                ntcp-\>seqno() = acker\_-\>Seqno();
                ntcp-\>ts() = otcp-\>ts();
        
                hdr\_ip* oip = (hdr\_ip*)opkt-\>access(off\_ip\_);
                hdr\_ip* nip = (hdr\_ip*)npkt-\>access(off\_ip\_);
                nip-\>flowid() = oip-\>flowid();
        
                hdr\_flags* of = (hdr\_flags*)opkt-\>access(off\_flags\_);
                hdr\_flags* nf = (hdr\_flags*)npkt-\>access(off\_flags\_);
                nf-\>ecn\_ = of-\>ecn\_;
        
                acker\_-\>append\_ack((hdr\_cmn*)npkt-\>access(off\_cmn\_),
                                   ntcp, otcp-\>seqno());
                send(npkt, 0);
        }
\end{verbatim}
The \fcn[]{recv} method overrides the \fcn[]{Agent::recv} method
(which merely discards the received packet).
It updates some internal state with the sequence number of the
received packet (and therefore requires the {\tt off\_tcp\_} variable
to be properly initialized.
It then generates an acknowledgment for the received packet.
The \fcn[]{ack} method makes liberal use of access to packet header
fields including separate accesses to the TCP header, IP header,
Flags header, and common header.
The call to \fcn[]{send} invokes the \fcn[]{Connector::send} method.

\subsection{Processing Responses at the Sender}
\label{sec:tcpsimpleack}

Once the simple TCP's peer receives data and generates an ACK, the
sender must (usually) process the ACK.
In the {\tt TcpAgent} agent, this is done as follows:
\begin{verbatim}
        /*
         * main reception path - should only see acks, otherwise the
         * network connections are misconfigured
         */
        void TcpAgent::recv(Packet *pkt, Handler*)
        {
                hdr\_tcp *tcph = (hdr\_tcp*)pkt-\>access(off\_tcp\_);
                hdr\_ip* iph = (hdr\_ip*)pkt-\>access(off\_ip\_);
                ...
                if (((hdr\_flags*)pkt-\>access(off\_flags\_))-\>ecn\_)
                        quench(1);
                if (tcph-\>seqno() \> last\_ack\_) {
                        newack(pkt);
                        opencwnd();
                } else if (tcph-\>seqno() == last\_ack\_) {
                        if (++dupacks\_ == NUMDUPACKS) {
                                \ldots
                        }
                }
                Packet::free(pkt);
                send(0, 0, maxburst\_);
       }
\end{verbatim}
This routine is invoked when an ACK arrives at the sender.
In this case, once the information in the ACK is processed (by {\tt newack})
the packet is no longer needed and is returned to the packet memory
allocator.
In addition, the receipt of the ACK indicates the possibility of sending
additional data, so the \fcn[]{TcpSimpleAgent::send} method is
invoked which attempts to send more data if the TCP window allows.

\subsection{Implementing Timers}
\label{sec:tcptimer}

As described in 
\href{the following chapter}{Chapter}{chap:timers}, specific
timer classes must be derived from an abstract base
\clsref{TimerHandler}{../ns-2/timer-handler.h}
defined in \textasciitilde\emph{ns}/{timer-handler.h}.  Instances of these
subclasses can then be used as various agent timers.
An agent may wish to override the \fcn[]{Agent::timeout} method
(which does nothing).
In the case of the Tahoe TCP agent, two timers are used:
a delayed send timer {\tt delsnd\_timer\_} 
and a retransmission timer {\tt rtx\_timer\_}.
\href{We describe the retransmission timer in TCP}{Section}{sec:timerexample}
as an example of timer usage.  

\section{Creating a New Agent}
\label{sec:createagent}

To create a new agent, one has to do the following:
\begin{enumerate}\itemsep0pt
        \item \href{decide its inheritance structure}{Section}{sec:pingexample},
                and create the appropriate class definitions,
        \item \href{define the \fcn[]{recv} and \fcn[]{timeout} methods}{%
                Section}{sec:agents:exmethods},
        \item define any necessary timer classes,
        \item \href{define OTcl linkage functions}{Section}{sec:agents:exlinkage},
        \item \href{write the necessary OTcl code to access the agent}{Section}{sec:agents:exotclcode}.
\end{enumerate}

The action required to create and agent can be illustrated
by means of a very simple example.
Suppose we wish to construct an agent which performs
the ICMP ECHO REQUEST/REPLY (or ``ping'') operations.

\subsection{Example: A ``ping'' requestor (Inheritance Structure)}
\label{sec:pingexample}

Deciding on the inheritance structure is a matter of personal choice, but is
likely to be related to the layer at which the agent will operate
and its assumptions on lower layer functionality.
The simplest type of Agent, connectionless datagram-oriented transport, is
the {\tt Agent/UDP} base class.  Traffic generators can easily be connected
to UDP Agents.
For protocols wishing to use a connection-oriented stream transport
(like TCP), the various TCP Agents could be used.
Finally, if a new transport or ``sub-transport'' protocol
is to be developed, using {\tt Agent}
as the base class would likely be the best choice.
In our example, we'll use Agent as the base class, given that
we are constructing an agent logically belonging to the IP layer
(or just above it).

We may use the following class definitions:
\begin{verbatim}
        class ECHO\_Timer;
 
        class ECHO\_Agent : public Agent {
         public:
                ECHO\_Agent();
                int command(int argc, const char*const* argv);
         protected:
                void timeout(int);
                void sendit();
                double interval\_;
                ECHO\_Timer echo\_timer\_;
        };

        class ECHO\_Timer : public TimerHandler {
        public:
                ECHO\_Timer(ECHO\_Agent *a) : TimerHandler() { a\_ = a; }
        protected:
                virtual void expire(Event *e);
                ECHO\_Agent *a\_;
        }; 
\end{verbatim}

\subsection{The \texttt{recv}() and \texttt{timeout}() Methods}
\label{sec:agents:exmethods}

The \fcn[]{recv} method is not defined here, as this agent
represents a request function and will generally not be receiving
events or packets\footnote{This is perhaps unrealistically simple.
An ICMP ECHO REQUEST agent would likely wish to process
ECHO REPLY messages.}.
By not defining the \fcn[]{recv} method, the base class version
of \fcn[]{recv} (\ie, \fcn[]{Connector::recv}) is used.
The \fcn[]{timeout} method is used to periodically send request packets.
The following \fcn[]{timeout} method is used, along with a helper
method, \fcn[]{sendit}:
\begin{verbatim}
        void ECHO\_Agent::timeout(int)
        {
                sendit();
                echo\_timer\_.resched(interval\_);
        }

        void ECHO\_Agent::sendit()
        {
                Packet* p = allocpkt();
                ECHOHeader *eh = ECHOHeader::access(p-\>bits());
                eh-\>timestamp() = Scheduler::instance().clock();
                send(p, 0);     // Connector::send()
        }

        void ECHO\_Timer::expire(Event *e)
        {
                a\_-\>timeout(0);
        }
\end{verbatim}
The \fcn[]{timeout} method simply arranges for \fcn[]{sendit} to be
executed every {\tt interval\_} seconds.
The \fcn[]{sendit} method creates a new packet with most of its
header fields already set up by \fcn[]{allocpkt}.
The packet is only lacks the current time stamp. 
The call to \fcn[]{access} provides for a structured interface to the
packet header fields, and is used to set the timestamp field.
Note that this agent uses its own special header (``ECHOHeader'').
The 
\href{creation and use of packet headers is described in
later chapter}{Chapter}{chap:pformat};
to send the packet to the next downstream node, \fcn[]{Connector::send}
is invoked without a handler.

\subsection{Linking the ``ping'' Agent with OTcl}
\label{sec:agents:exlinkage}

We have the 
\href{methods and mechanisms for establishing OTcl Linkage earlier}{%
        Chapter}{chap:otcl:intro}.
This section is a brief review of the essential features of that
earlier chapter, and describes the minimum functionality required to 
create the ping agent.

There are three items we must handle to properly link our agent
with Otcl.
First we need to establish a mapping between the OTcl name
for our class and the actual object created when an
instantiation of the class is requested in OTcl.
This is done as follows:
\begin{verbatim}
        static class ECHOClass : public TclClass {
        public:
                ECHOClass() : TclClass("Agent/ECHO") {}
                TclObject* create(int argc, const char*const* argv) {
                        return (new ECHO\_Agent());
                }
        } class\_echo;
\end{verbatim}
Here, a {\em static} object ``class\_echo'' is created. It's constructor
(executed immediately when the simulator is executed) places the class name
``Agent/ECHO'' into the OTcl name space.
The mixing of case is by convention;
recall from Section~\ref{sec:TclClass} in the earlier chapters that
the ``/'' character is a hierarchy delimiter for the interpreted hierarchy.
The definition of the \fcn[]{create} method specifies how a C++
shadow object should be created when
the OTcl interpreter is instructed to create an
object of class ``Agent/ECHO''.  In this case, a dynamically-allocated
object is returned.  This is the normal way new C++ shadow objects
are created.

Once we have the object creation set up, we will want to link
C++ member variables with corresponding variables in the OTcl
nname space, so that accesses to OTcl variables are actually
backed by member variables in C++.
Assume we would like OTcl to be able to adjust the sending
interval and the packet size.
This is accomplished in the class's constructor:
\begin{verbatim}
        ECHO\_Agent::ECHO\_Agent() : Agent(PT\_ECHO)
        {
                bind\_time("interval\_", &interval\_);
                bind("packetSize\_", &size\_);
        }
\end{verbatim}
Here, the C++ variables {\tt interval\_} and {\tt size\_} are
linked to the OTcl instance variables {\tt interval\_} and
{\tt packetSize\_}, respectively.
Any read or modify operation to the Otcl variables will result
in a corresponding access to the underlying C++ variables.
The \href{details of the \fcn[]{bind} methods are described elsewhere}{%
        Section}{sec:VarBinds}.
The defined constant {\tt PT\_ECHO} is passed to the \fcn[]{Agent}
constuctor so that the \fcn[]{Agent::allocpkt} method may set
the \href{packet type field used by the trace support}{%
        Section}{sec:traceptype}.
In this case, {\tt PT\_ECHO} 
\href{represents a new packet type and must be defined in \textasciitilde\emph{ns}/{trace.h}}{%
        Section}{sec:traceformat}.

Once object creation and variable binding is set up, we may
want to \href{create methods implemented in C++ but which can
be invoked from OTcl}{Section}{sec:Commands}.
These are often control functions that initiate, terminate or
modify behavior.
In our present example, we may wish to be able to start the
ping query agent from OTcl using a ``start'' directive.
This may be implemented as follows:
\begin{verbatim}
        int ECHO\_Agent::command(int argc, const char*const* argv)
        {
                if (argc == 2) {
                        if (strcmp(argv[1], "start") == 0) {
                                timeout(0);
                                return (TCL\_OK);
                        }
                }
                return (Agent::command(argc, argv));
        }
\end{verbatim}
Here, the \fcn[]{start} method available to OTcl simply calls
the C++ member function \fcn[]{timeout} which initiates the
first packet generation and schedules the next.
Note this class is so simple it does not even include a
way to be stopped.

\subsection{Using the agent through OTcl}
\label{sec:agents:exotclcode}

The agent we have created will have to be instantiated and attached
to a node.
Note that a node and simulator object is assumed to have
already been created.
The following OTcl code performs these functions:
\begin{verbatim}
        set echoagent [new Agent/ECHO]
        \$simulator attach-agent \$node \$echoagent
\end{verbatim}
To set the interval and packet size, and start packet generation,
the following OTcl code is executed:
\begin{verbatim}
        \$echoagent set dst\_ \$dest
        \$echoagent set fid\_ 0
        \$echoagent set prio\_ 0
        \$echoagent set flags\_ 0
        \$echoagent set interval\_ 1.5
        \$echoagent set packetSize\_ 1024
        \$echoagent start
\end{verbatim}
This will cause our agent to generate one 1024-byte packet destined for
node {\tt \$dest} every 1.5 seconds.

\section{The Agent API}
\label{sec:agents:api}

Simulated applications may be implemented on top of protocol agents.  Chapter
\ref{chap:applications} describes the API used by applications to  access the 
services provided by the protocol agent.


\section{Different agent objects}
\label{sec:agentobjects}
Class Agent forms the base class from which different types of objects
like Nullobject, TCP etc are derived. The methods for Agent class are
described in the next section. Configuration parameters for:
\begin{description}
\item[fid\_] Flowid.
\item[prio\_] Priority. 
\item[agent\_addr\_] Address of this agent. 
\item[agent\_port\_] Port adress of this agent. 
\item[dst\_addr\_ ] Destination address for the agent.
\item[dst\_port\_] Destination port address for the agent.
\item[flags\_]
\item[ttl\_] TTL defaults to 32.
\end{description}
There are no state variables specific to the generic agent class. Other
objects derived from Agent are given below:

\begin{description}

\item[Null Objects]
Null objects are a subclass of agent objects that implement a traffic
sink. They inherit all of the generic agent object functionality. There
are no methods specific to this object. The state variables are:
\begin{itemize}
\item sport\_
\item dport\_
\end{itemize}

\item[LossMonitor Objects]
LossMonitor objects are a subclass of agent objects that implement a
traffic sink which also maintains some statistics about the received data
e.g., number of bytes received, number of packets lost etc. They inherit
all of the generic agent object functionality. 

{\tt \$lossmonitor clear}\\
Resets the expected sequence number to -1. 

State Variables are:
\begin{description}
\item[nlost\_] Number of packets lost. 

\item[npkts\_] Number of packets received. 

\item[bytes\_] Number of bytes received. 

\item[lastPktTime\_] Time at which the last packet was received. 

\item[expected\_] The expected sequence number of the next packet. 
\end{description}

\item[TCP objects]
TCP objects are a subclass of agent objects that implement the BSD Tahoe
TCP transport protocol as described in paper: "Fall, K., and Floyd, S.
Comparisons of Tahoe, Reno, and Sack TCP. December 1995." URL ftp://
ftp.ee.lbl.gov/papers/sacks.ps.Z. They inherit
all of the generic agent functionality. Configuration Parameters are:
\begin{description}

\item[window\_] The upper bound on the advertised window for the TCP
connection. 

\item[maxcwnd\_]
The upper bound on the congestion window for the TCP connection. Set to
zero to ignore. (This is the default.) 

\item[windowInit\_]
The initial size of the congestion window on slow-start. 

\item[windowOption\_]
The algorithm to use for managing the congestion window. 

\item[windowThresh\_]
Gain constant to exponential averaging filter used to compute awnd (see
below). For investigations of different window-increase algorithms. 

\item[overhead\_]
The range of a uniform random variable used to delay each output packet.
The idea is to insert random delays at the source in order to avoid phase
effects, when desired [see Floyd, S., and Jacobson, V. On Traffic Phase
Effects in Packet-Switched Gateways. Internetworking: Research and
Experience, V.3 N.3, September 1992. pp. 115-156 ]. This has only been
implemented for the Tahoe ("tcp") version of tcp, not for tcp-reno. This
is not intended to be a realistic model of CPU processing overhead. 

\item[ecn\_] Set to true to use explicit congestion notification in
addition to packet drops to signal congestion. This allows a Fast
Retransmit after a quench() due to an ECN (explicit congestion
notification) bit. 

\item[packetSize\_]
The size in bytes to use for all packets from this source. 

\item[tcpTick\_]
The TCP clock granularity for measuring roundtrip times. Note that it is
set by default to the non-standard value of 100ms. 

\item[bugFix\_]
Set to true to remove a bug when multiple fast retransmits are allowed for
packets dropped in a single window of data. 

\item[maxburst\_]
Set to zero to ignore. Otherwise, the maximum number of packets that the
source can send in response to a single incoming ACK. 

\item[slow\_start\_restart\_]
Set to 1 to slow-start after the connection goes idle. On by default. 

\item[syn\_]
Set to false to disable modeling the initial SYN/SYNACK exchange. On by default.
Note: if this is set to false and the DelAck sink is used, it's advisable to also disable the sink's ``SYN\_immediate\_ack\_'' flag.
\end{description}

Defined Constants are:
\begin{description}
\item[MWS] The Maximum Window Size in packets for a TCP connection. MWS
determines the size of an array in tcp-sink.cc. The default for MWS is
1024 packets. For Tahoe TCP, the "window" parameter, representing the
receiver's advertised window, should be less than MWS-1. For Reno TCP, the
"window" parameter should be less than (MWS-1)/2. 
\end{description}

State Variables are:
\begin{description}

\item[dupacks\_]
Number of duplicate acks seen since any new data was acknowledged. 

\item[seqno\_]
Highest sequence number for data from data source to TCP. 

\item[t\_seqno\_]
Current transmit sequence number. 

\item[ack\_] Highest acknowledgment seen from receiver. cwnd\_
Current value of the congestion window. 

\item[awnd\_]
Current value of a low-pass filtered version of the congestion window. For
investigations of different window-increase algorithms. 

\item[ssthresh\_]
Current value of the slow-start threshold. 

\item[rtt\_] Round-trip time estimate. 

\item[srtt\_]
Smoothed round-trip time estimate. 

\item[rttvar\_]
Round-trip time mean deviation estimate. 

\item[backoff\_]
Round-trip time exponential backoff constant. 
\end{description}

\item[TCP/Reno Objects]
TCP/Reno objects are a subclass of TCP objects that implement the Reno TCP
transport protocol described in paper: "Fall, K., and Floyd, S.
Comparisons of Tahoe, Reno, and Sack TCP. December 1995." URL ftp://
ftp.ee.lbl.gov/papers/sacks.ps.Z. There are no methods,
configuration parameters or state variables specific to this object. 

\item[TCP/Newreno Objects]
TCP/Newreno objects are a subclass of TCP objects that implement a
modified version of the BSD Reno TCP transport protocol. 
There are no methods or state variables specific to this object. 

Configuration Parameters are:
\begin{description}

\item[newreno\_changes\_]
Set to zero for the default New Reno described in "Fall, K., and Floyd, S.
Comparisons of Tahoe, Reno, and Sack TCP. December 1995". Set to 1 for
additional New Reno algorithms [see Hoe, J., Improving the Start-up
Behavior of a Congestion Control Scheme for TCP. in SIGCOMM 96, August
1996, pp. 270-280. URL 
http://www.acm.org/sigcomm/sigcomm96/papers/hoe.html.]; this includes the
estimation of the ssthresh parameter during slow-start. 
\end{description}


\item[TCP/Vegas Objects]
There are no methods or configuration parameters specific to this
object. State variables are:
\begin{itemize}
\item v\_alpha\_
\item v\_beta\_
\item v\_gamma\_
\item v\_rtt\_
\end{itemize}


\item[TCP/Sack1 Objects]
TCP/Sack1 objects are a subclass of TCP objects that implement the BSD
Reno TCP transport protocol with Selective Acknowledgement Extensions
described in "Fall, K., and Floyd, S. Comparisons of Tahoe, Reno, and
Sack TCP. December 1995". URL ftp:// ftp.ee.lbl.gov/papers/sacks.ps.Z. 
They inherit all of the TCP object functionality. There are no methods,
configuration parameters or state variables specific to this object. 


\item[TCP/FACK Objects]
TCP/Fack objects are a subclass of TCP objects that implement the BSD Reno
TCP transport protocol with Forward Acknowledgement congestion control. 
They inherit all of the TCP object functionality. There are no methods or
state variables specific to this object. 

Configuration Parameters are:
\begin{description}
\item[ss-div4]
Overdamping algorithm. Divides ssthresh by 4 (instead of 2) if congestion
is detected within 1/2 RTT of slow-start. (1=Enable, 0=Disable) 

\item[rampdown]
Rampdown data smoothing algorithm. Slowly reduces congestion window rather
than instantly halving it. (1=Enable, 0=Disable) 
\end{description}


\item[TCP/FULLTCP Objects]
This section has not yet been added here. The implementation
and the configuration parameters are described in paper: "Fall, K.,
Floyd, S., and Henderson, T., Ns Simulator Tests for Reno FullTCP.
July, 1997." URL ftp://ftp.ee.lbl.gov/papers/fulltcp.ps. 


\item[TCPSINK Objects]
TCPSink objects are a subclass of agent objects that implement a receiver
for TCP packets. The simulator only implements "one-way" TCP connections,
where the TCP source sends data packets and the TCP sink sends ACK
packets. TCPSink objects inherit all of the generic agent functionality.
There are no methods or state variables specific to the TCPSink object. 
Configuration Parameters are
\begin{description}
\item[packetSize\_]
The size in bytes to use for all acknowledgment packets. 

\item[maxSackBlocks\_]
The maximum number of blocks of data that can be acknowledged in a SACK
option. For a receiver that is also using the time stamp option [RFC
1323], the SACK option specified in RFC 2018 has room to include three
SACK blocks. This is only used by the TCPSink/Sack1 subclass. This value
may not be increased within any particular TCPSink object after that
object has been allocated. (Once a TCPSink object has been allocated, the
value of this parameter may be decreased but not increased). 
\end{description}


\item[TCPSINK/DELACK Objects]
DelAck objects are a subclass of TCPSink that implement a delayed-ACK
receiver for TCP packets. They inherit all of the TCPSink object
functionality. There are no methods or state variables specific to the
DelAck object. 
Configuration Parameters are:
\begin{description}
\item[interval\_]
The amount of time to delay before generating an acknowledgment for a
single packet. If another packet arrives before this time expires,
generate an acknowledgment immediately. 

\item[RFC2581\_immediate\_ack\_]
A boolean flag. If true, conforms to RFC2581 (section 4.2) and only delays
the ACK if we know we're not doing recovery, i.e. not gap-filling.
Otherwise all ACKs are delayed. The default value is true.

\item[SYN\_immediate\_ack\_]
A boolean flag. If true, the first packet in sequence (seqno == 0) is
always ACKed immediately. This simulates the behavior of the FullTCP
agent, which ACKs a SYN immediately. The default value is true.
See also the ``syn\_'' flag of the one-way TcpAgent.
\end{description}


\item[TCPSINK/SACK1 Objects]
TCPSink/Sack1 objects are a subclass of TCPSink that implement a SACK
receiver for TCP packets. They inherit all of the TCPSink object
functionality. There are no methods, configuration parameters or state
variables specific to this object. 


\item[TCPSINK/SACK1/DELACK Objects]
TCPSink/Sack1/DelAck objects are a subclass of TCPSink/Sack1 that
implement a delayed-SACK receiver for TCP packets. They inherit all of the
TCPSink/Sack1 object functionality. There are no methods or state
variables specific to this object. 
Configuration Parameters are:
\begin{description}

\item[interval\_]
The amount of time to delay before generating an acknowledgment for a
single packet. If another packet arrives before this time expires,
generate an acknowledgment immediately. 
\end{description}
\end{description}



\section{Commands at a glance}
\label{sec:agentscommand}

Following are the agent related commands used in simulation scripts:
\begin{flushleft}
{\tt ns\_ attach-agent \<node\> \<agent\>}\\
This command attaches the <agent> to the <node>. We assume here that the
<agent> has already been created. An agent is typically created by
{\tt set agent [new Agent/AgentType]}
where Agent/AgentType defines the class definiton of the specified agent
type.


{\tt \$agent port}\\
This returns the port number to which the agent is attached.


{\tt \$agent dst-port}\\
This returns the port number of the destination.
When any connection is setup between 2 nodes, each agent stores the 
destination port in its instance variable called {\tt dst\_port\_}.


{\tt \$agent attach-app \<s\_type\>}\\
This commands attaches an application of type {\tt \<s\_type\>} to the agent.
A handle to the application object is returned. Also note that the application
type must be defined as a packet type in packet.h.


{\tt \$agent attach-source \<s\_type\>}\\
This used to be the procedure to attach source of type {\tt \<s\_type\>} to
the agent. But this is obsolete now. Use attach-app (described above)
instead.


{\tt \$agent attach-tbf \<tbf\>}\\
Attaches a token bucket filter (tbf) to the agent.


{\tt \$ns\_ connect \<src\> \<dst\>}\\
Sets up a connection between the src and dst agents. 


{\tt \$ns\_ create-connection \<srctype\> \<src\> \<dsttype\> \<dst\> \<pktclass\>}\\
This sets up a complete connection between two agents. First creates a source
of type <srctype> and binds it to <src>. Then creates a destination of type
<dsttype> and binds it to <dst>. Finally connects the src and dst agents and
returns a handle to the source agent.


{\tt \$ns\_ create-connection-list \<srctype\> \<src\> \<dsttype\> \<dst\> \<pktclass\>}\\
This command is exactly similar to create-connection described above. But
instead of returning only the source-agent, this returns a list of source and
destination agents.


Internal procedures:

{\tt \$ns\_ simplex-connect \<src\> \<dst\>}\\
This is an internal method that actually sets up an unidirectional connection
between the <src> agent and <dst> agent. It simply sets the destination address
and destination port of the <src> as <dst>'s agent-address and agent-port.
The "connect" described above calls this method twice to set up a bi-directional
connection between the src and dst.


{\tt \$agent set \<args\>}\\
This is an internal procedure used to inform users of the backward compatibility
issues resulting from the upgrade to 32-bit addressing space currently used
in \emph{ns}.

{\tt \$agent attach-trace \<file\>}\\
This attaches the <file> to the agent to allow nam-tracing of the agent
events.


In addition to the agent related procedures described here, there are additional
methods that support different type of agents like Agent/Null, Agent/TCP,
Agent/CBR, Agent/TORA, Agent/mcast etc. These additional methods along
with the procedures described here can be found in \emph{ns}/tcl/lib/(ns-agent.tcl,
ns-lib.tcl, ns-mip.tcl, ns-mobilenode.tcl, ns-namsupp.tcl, ns-queue.tcl,
ns-route.tcl, ns-sat.tcl, ns-source.tcl). They are also described in the
previous section.

\end{flushleft} 

\endinput
